// Generated by CoffeeScript 1.3.1
(function() {
  var Chrome, Galaxy, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_SPACE, KEY_UP, Level, MODE_DEAD, MODE_FINAL, MODE_FINISH, MODE_PLAY, MODE_START, Mass, Planet, Player, Sun, canvas, chrome, ctx, currentLevel, death, finish, getColor, h, key_dir, levels, planets, playMode, player, rotation, runningOutColors, setPixel, startGame, startOver, w,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Mass = (function() {

    Mass.name = 'Mass';

    function Mass(_x, _y, _radius, _mass) {
      this.x = _x;
      this.y = _y;
      this.radius = _radius;
      this.mass = _mass;
    }

    Mass.prototype.safe = true;

    Mass.prototype.goal = false;

    Mass.prototype.distance = 0;

    Mass.prototype.color = [200, 200, 200];

    Mass.prototype.markerColor = [127, 127, 127];

    Mass.prototype.onContact = function(player) {
      return this;
    };

    Mass.prototype.physics = function(player) {
      var angle, p, pull;
      this.distance = this.distanceTo(player);
      if (this.distance < this.radius * 5) {
        if (this.distance > 0) {
          p = 1 - (Math.sin(this.distance / (this.radius * 5) * Math.PI / 2));
          pull = p * (this.radius + 100) * .01;
          angle = Math.PI / 2 - Math.atan2(this.x - player.x, this.y - player.y);
          player.velocityX += (Math.cos(angle)) * pull;
          player.velocityY += (Math.sin(angle)) * pull;
        } else {
          this.onContact(player);
        }
      }
      return this;
    };

    Mass.prototype.draw = function(s, g) {
      var angle, dist, h2, size, w2, x, x1, x2, x3, y, y1, y2, y3;
      this.s = s;
      this.g = g;
      x = this.x - g.offsetX;
      y = this.y - g.offsetY;
      angle = Math.atan2(x, y);
      dist = Math.sqrt((Math.pow(x, 2)) + (Math.pow(y, 2)));
      angle += g.rotation;
      x = Math.cos(angle) * dist;
      y = Math.sin(angle) * dist;
      size = this.radius * 2;
      w2 = g.w / 2;
      h2 = g.h / 2;
      if ((-w2 - this.radius < x && x < w2 + this.radius) && (-h2 - this.radius < y && y < h / 2 + this.radius)) {
        x += w2;
        y += h2;
        s.noStroke();
        s.fill(this.color[0], this.color[1], this.color[2]);
        s.ellipse(x, y, size, size);
      } else {
        angle = Math.PI / 2 - Math.atan2(x, y);
        dist = this.distance;
        if ((Math.abs(x)) > w2) {
          dist = Math.abs(w2 / Math.cos(angle));
          x = (Math.cos(angle)) * dist;
          y = (Math.sin(angle)) * dist;
        }
        if ((Math.abs(y)) > h2) {
          dist = Math.abs(h2 / Math.sin(angle));
          x = (Math.cos(angle)) * dist;
          y = (Math.sin(angle)) * dist;
        }
        x += w2;
        y += h2;
        s.strokeWeight(2);
        s.stroke(this.markerColor[0], this.markerColor[1], this.markerColor[2], 222);
        s.noFill();
        x1 = (Math.cos(angle + .01)) * (dist - 20) + w2;
        y1 = (Math.sin(angle + .01)) * (dist - 20) + h2;
        x2 = (Math.cos(angle)) * (dist - 5) + w2;
        y2 = (Math.sin(angle)) * (dist - 5) + h2;
        x3 = (Math.cos(angle - .01)) * (dist - 20) + w2;
        y3 = (Math.sin(angle - .01)) * (dist - 20) + h2;
        s.beginShape();
        s.vertex(x1, y1);
        s.vertex(x2, y2);
        s.vertex(x3, y3);
        s.endShape();
      }
      return this;
    };

    Mass.prototype.distanceTo = function(player) {
      return (Math.sqrt((Math.pow(this.x - player.x, 2)) + (Math.pow(this.y - player.y, 2)))) - this.radius;
    };

    return Mass;

  })();

  Planet = (function(_super) {

    __extends(Planet, _super);

    Planet.name = 'Planet';

    function Planet(_x, _y, _radius, _mass) {
      var lightness;
      lightness = Math.random() * 40;
      this.color = [Math.random() * lightness + 200, Math.random() * lightness + 200, Math.random() * lightness + 200];
      Planet.__super__.constructor.call(this, _x, _y, _radius, _mass);
    }

    Planet.prototype.setGoal = function() {
      this.goal = true;
      this.color = [110, 200, 130];
      return this.markerColor = [0, 255, 0];
    };

    Planet.prototype.color = [255, 255, 255];

    Planet.prototype.markerColor = [222, 222, 222];

    return Planet;

  })(Mass);

  Sun = (function(_super) {

    __extends(Sun, _super);

    Sun.name = 'Sun';

    function Sun(_x, _y, _radius, _mass) {
      Sun.__super__.constructor.call(this, _x, _y, _radius, _mass);
    }

    Sun.prototype.safe = false;

    Sun.prototype.color = [255, 200, 50];

    Sun.prototype.markerColor = [255, 0, 0];

    Sun.prototype.onContact = function(p) {
      p.burnt = true;
      p.alive = false;
      return Sun.__super__.onContact.call(this, p);
    };

    Sun.prototype.draw = function(_s, _g) {
      return Sun.__super__.draw.call(this, _s, _g);
    };

    return Sun;

  })(Mass);

  Player = (function() {

    Player.name = 'Player';

    function Player() {
      var walkcb,
        _this = this;
      this.direction = this.DIR_RIGHT;
      this.currentImage = this.IMG_STANDING;
      this.walkingImage = this.IMG_WALKING;
      walkcb = function() {
        return _this.switchWalk();
      };
      setInterval(walkcb, 200);
    }

    Player.prototype.activated = false;

    Player.prototype.alive = true;

    Player.prototype.burnt = false;

    Player.prototype.x = 0;

    Player.prototype.y = 0;

    Player.prototype.width = 20;

    Player.prototype.height = 25;

    Player.prototype.velocityX = 0;

    Player.prototype.velocityY = 0;

    Player.prototype.nearestPlanet = false;

    Player.prototype.jumping = false;

    Player.prototype.jumpVelocity = 0;

    Player.prototype.maxJump = 40;

    Player.prototype.minJump = 10;

    Player.prototype.maxSpeed = 3;

    Player.prototype.onGround = false;

    Player.prototype.walking = false;

    Player.prototype.maxOxygen = 1000;

    Player.prototype.oxygen = 1000;

    Player.prototype.DEAD = "dead";

    Player.prototype.FINISHED = "finished";

    Player.prototype.DIR_RIGHT = "right";

    Player.prototype.DIR_LEFT = "left";

    Player.prototype.IMG_STANDING = "standing";

    Player.prototype.IMG_WALKING = "walking";

    Player.prototype.IMG_SQUATTING = "squatting";

    Player.prototype.IMG_FLYING = "flying";

    Player.prototype.IMG_BURNT = "burnt";

    Player.prototype.walkingImage = "";

    Player.prototype.currentImage = "";

    Player.prototype.lastImageChange = 0;

    Player.prototype.accel = function(angle, force, cap) {
      if (this.activated) {
        this.velocityX += (Math.cos(angle)) * force;
        this.velocityY += (Math.sin(angle)) * force;
        if (cap && Math.sqrt((Math.pow(this.velocityX, 2)) + (Math.pow(this.velocityY, 2)) > this.maxSpeed)) {
          angle = Math.PI / 2 - Math.atan2(this.velocityX, this.velocityY);
          this.velocityX = (Math.cos(angle)) * this.maxSpeed;
          return this.velocityY = (Math.sin(angle)) * this.maxSpeed;
        }
      }
    };

    Player.prototype.calculatePhysics = function(planets) {
      var nearPlanet, og, planet, _fn, _i, _len,
        _this = this;
      og = this.onGround;
      this.onGround = false;
      nearPlanet = false;
      _fn = function(planet) {
        var angle, dist;
        if (!og || planet.distance < 20) {
          planet.physics(_this);
        }
        dist = planet.distance;
        if (dist < planet.radius) {
          nearPlanet = true;
        }
        if (dist < 10) {
          _this.onGround = true;
          _this.velocityX *= .99;
          _this.velocityY *= .99;
          if (dist <= 0) {
            if (!planet.safe) {
              _this.death();
            }
            if (planet.goal) {
              _this.finished();
            }
            angle = Math.PI / 2 - Math.atan2(planet.x - _this.x, planet.y - _this.y);
            _this.x = planet.x - (Math.cos(angle)) * planet.radius;
            _this.y = planet.y - (Math.sin(angle)) * planet.radius;
          }
          if (dist < 5 && !_this.walking) {
            _this.velocityX *= 0.5;
            return _this.velocityY *= 0.5;
          }
        }
      };
      for (_i = 0, _len = planets.length; _i < _len; _i++) {
        planet = planets[_i];
        _fn(planet);
      }
      if (nearPlanet) {
        this.velocityX *= .99;
        this.velocityY *= .99;
      }
      if (!this.onGround) {
        this.walking = false;
      }
      return this;
    };

    Player.prototype.move = function() {
      var d, t;
      if (!this.burnt) {
        this.x += this.velocityX;
        this.y += this.velocityY;
      }
      d = new Date();
      t = d.getTime();
      if (this.onGround && !this.jumping) {
        if (Math.abs(this.velocityX) + Math.abs(this.velocityY) > 0.1) {
          this.currentImage = this.walkingImage;
        } else {
          this.currentImage = this.IMG_STANDING;
        }
      } else {
        if (this.jumping) {
          this.currentImage = this.IMG_SQUATTING;
        } else {
          this.currentImage = this.IMG_FLYING;
        }
      }
      return this;
    };

    Player.prototype.switchWalk = function() {
      if (this.walkingImage !== this.IMG_WALKING) {
        return this.walkingImage = this.IMG_WALKING;
      } else {
        return this.walkingImage = this.IMG_STANDING;
      }
    };

    Player.prototype.findNearestPlanet = function(planets, log) {
      var nearestDistance, planet, _fn, _i, _len,
        _this = this;
      this.nearestPlanet = planets[0];
      nearestDistance = this.nearestPlanet.distance;
      _fn = function(planet) {
        var dist;
        dist = planet.distance;
        if (dist < nearestDistance) {
          _this.nearestPlanet = planet;
          return nearestDistance = dist;
        } else {

        }
      };
      for (_i = 0, _len = planets.length; _i < _len; _i++) {
        planet = planets[_i];
        _fn(planet);
      }
      return this.nearestPlanet;
    };

    Player.prototype.startJumping = function() {
      var cb,
        _this = this;
      if (this.alive && this.activated) {
        this.jumping = true;
        this.jumpVelocity = this.minJump;
        cb = function() {
          _this.jumpVelocity = _this.jumpVelocity + 1 < _this.maxJump ? _this.jumpVelocity + 1 : _this.maxJump;
          if (_this.jumping) {
            return setTimeout(cb, 30);
          }
        };
        cb();
      }
      return this;
    };

    Player.prototype.jump = function() {
      if (this.alive && this.activated) {
        this.accel(this.g.rotation - Math.PI, this.jumpVelocity);
        this.jumping = false;
        this.jumpVelocity = this.minJump;
      }
      return this;
    };

    Player.prototype.draw = function(s, g) {
      var angle, dist, x, y;
      this.s = s;
      this.g = g;
      if (this.activated) {
        if (this.oxygen > 0) {
          this.oxygen -= 2;
        } else {
          this.death();
        }
      }
      x = this.x - this.g.offsetX;
      y = this.y - this.g.offsetY;
      angle = Math.atan2(x, y);
      dist = Math.sqrt((Math.pow(x, 2)) + (Math.pow(y, 2)));
      angle += this.g.rotation;
      x = (Math.cos(angle)) * dist;
      y = (Math.sin(angle)) * dist;
      x += this.g.w / 2;
      y += this.g.h / 2;
      if (!this.alive) {
        this.currentImage = this.burnt ? this.IMG_BURNT : this.IMG_STANDING;
      }
      return this.s.image(this.s[this.currentImage + "_" + this.direction], x - this.width / 2, y - this.height);
    };

    Player.prototype.reset = function() {
      this.velocityX = this.velocityY = 0;
      this.jumping = false;
      this.jumpVelocity = 0;
      this.onGround = false;
      this.burnt = false;
      this.alive = true;
      this.activated = true;
      return this;
    };

    Player.prototype.death = function() {
      var cb,
        _this = this;
      this.activated = false;
      this.alive = false;
      cb = function() {
        return radio(_this.DEAD).broadcast();
      };
      return setTimeout(cb, 1000);
    };

    Player.prototype.finished = function() {
      var cb,
        _this = this;
      this.activated = false;
      cb = function() {
        return radio(_this.FINISHED).broadcast();
      };
      return setTimeout(cb, 400);
    };

    return Player;

  })();

  Galaxy = (function() {

    Galaxy.name = 'Galaxy';

    Galaxy.prototype.planets = [];

    Galaxy.prototype.offsetX = 0;

    Galaxy.prototype.offsetY = 0;

    Galaxy.prototype.w = 100;

    Galaxy.prototype.h = 100;

    Galaxy.prototype.rotation = 0;

    Galaxy.prototype.stars = false;

    function Galaxy() {}

    Galaxy.prototype.setStageSize = function(_w, _h) {
      this.w = _w;
      this.h = _h;
      return this;
    };

    Galaxy.prototype.draw = function(_sketch) {
      var planet, _i, _len, _ref;
      this.sketch = _sketch;
      this.drawStars();
      _ref = this.planets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        planet = _ref[_i];
        this.drawPlanet(planet);
      }
      return this.player.draw(this.sketch, this, this.rotation);
    };

    Galaxy.prototype.drawPlanet = function(planet) {
      return planet.draw(this.sketch, this, this.rotation);
    };

    Galaxy.prototype.drawStars = function() {
      this.sketch.translate(this.w / 2, this.h / 2);
      this.sketch.rotate(this.rotation);
      this.sketch.image(this.sketch.stars, -500, -500);
      this.sketch.rotate(-this.rotation);
      return this.sketch.translate(-this.w / 2, -this.h / 2);
    };

    return Galaxy;

  })();

  Level = (function() {

    Level.name = 'Level';

    function Level() {
      this.galaxy = new Galaxy();
      this;

    }

    Level.prototype.title = "";

    Level.prototype.description = "";

    Level.prototype.planets = [];

    Level.prototype.startingPosition = {
      x: 0,
      y: 0
    };

    Level.prototype.startingOxygen = 1000;

    Level.prototype.maxJump = 40;

    Level.prototype.rotation = 0;

    Level.prototype.setTitle = function(t) {
      this.title = t;
      return this;
    };

    Level.prototype.setDescription = function(d) {
      this.description = d;
      return this;
    };

    Level.prototype.setStageSize = function(_w, _h) {
      this.w = _w;
      this.h = _h;
      this.galaxy.setStageSize(this.w, this.h);
      return this;
    };

    Level.prototype.setPlayer = function(_player) {
      this.player = _player;
      this.galaxy.player = this.player;
      return this;
    };

    Level.prototype.setPlanets = function(_planets) {
      this.planets = _planets;
      this.galaxy.planets = this.planets;
      return this;
    };

    Level.prototype.setGoal = function(p) {
      p.setGoal();
      this.planets.push(p);
      return this;
    };

    Level.prototype.setPosition = function(sp) {
      this.startingPosition = sp;
      return this;
    };

    Level.prototype.setOxygen = function(o) {
      this.startingOxygen = o;
      return this;
    };

    Level.prototype.setJump = function(j) {
      this.startingJump = j;
      return this;
    };

    Level.prototype.reset = function() {
      this.player.x = this.galaxy.offsetX = parseInt(this.startingPosition.x);
      this.player.y = this.galaxy.offsetY = parseInt(this.startingPosition.y);
      this.player.oxygen = this.player.maxOxygen = this.startingOxygen;
      this.player.maxJump = this.maxJump;
      this.player.reset();
      return this.rotation = 0;
    };

    Level.prototype.start = function() {
      var idealRotation, nearestPlanet;
      this.reset();
      this.player.calculatePhysics(this.galaxy.planets);
      nearestPlanet = this.player.findNearestPlanet(this.galaxy.planets, false);
      idealRotation = Math.PI / 2 - Math.atan2(nearestPlanet.x - this.player.x, nearestPlanet.y - this.player.y);
      this.rotation = idealRotation;
      window.rotation = this.rotation;
      return this;
    };

    Level.prototype.redraw = function(_s) {
      var diff, idealRotation, nearestPlanet;
      this.s = _s;
      nearestPlanet = this.player.findNearestPlanet(this.galaxy.planets, false);
      idealRotation = Math.PI / 2 - Math.atan2(nearestPlanet.x - this.player.x, nearestPlanet.y - this.player.y);
      diff = Math.abs(idealRotation - this.rotation);
      if ((Math.abs(idealRotation - Math.PI * 2 - this.rotation)) < diff) {
        idealRotation = idealRotation - Math.PI * 2;
      }
      if ((Math.abs(idealRotation + Math.PI * 2 - this.rotation)) < diff) {
        idealRotation = idealRotation + Math.PI * 2;
      }
      this.rotation += (idealRotation - this.rotation) * .08;
      if (this.rotation < 0) {
        this.rotation += Math.PI * 2;
      }
      this.rotation = this.rotation % (Math.PI * 2);
      this.galaxy.rotation = this.rotation;
      this.galaxy.offsetX += parseFloat(this.player.x - this.galaxy.offsetX) * .3;
      this.galaxy.offsetY += parseFloat(this.player.y - this.galaxy.offsetY) * .3;
      if (this.player.activated) {
        this.player.move().calculatePhysics(this.galaxy.planets);
      }
      this.galaxy.draw(this.s);
      return this;
    };

    return Level;

  })();

  Chrome = (function() {

    Chrome.name = 'Chrome';

    function Chrome(w, h) {
      this.w = w;
      this.h = h;
    }

    Chrome.prototype.barWidth = 200;

    Chrome.prototype.barHeight = 26;

    Chrome.prototype.barPadding = 4;

    Chrome.prototype.marginTop = 40;

    Chrome.prototype.marginBottom = 40;

    Chrome.prototype.marginLeft = 40;

    Chrome.prototype.marginRight = 40;

    Chrome.prototype.mapX = 40;

    Chrome.prototype.mapY = 40;

    Chrome.prototype.mapWidth = 200;

    Chrome.prototype.mapHeight = 400;

    Chrome.prototype.draw = function(s, player) {
      var c;
      this.s = s;
      this.player = player;
      this.s.stroke(255);
      this.s.fill(0);
      this.s.rect(this.w - this.barWidth - this.marginRight, this.marginTop + 10, this.barWidth, this.barHeight);
      if (this.player.jumping) {
        this.s.noStroke();
        this.s.fill(255, 0, 0);
        this.s.rect(this.w - this.barWidth - this.marginRight + this.barPadding, this.marginTop + this.barPadding + 10, (this.barWidth - this.barPadding * 2) * (this.player.jumpVelocity - this.player.minJump) / (this.player.maxJump - this.player.minJump), this.barHeight - this.barPadding * 2);
      }
      this.drawText("jump meter", this.w - this.barWidth - this.marginRight, this.marginTop);
      this.s.stroke(255);
      this.s.fill(0);
      this.s.rect(this.marginLeft, this.marginTop + 10, this.barWidth, this.barHeight);
      this.s.noStroke();
      c = getColor(this.player.oxygen, 0, this.player.maxOxygen, runningOutColors);
      this.s.fill(c.r, c.g, c.b);
      this.s.rect(this.marginLeft + this.barPadding, this.marginTop + this.barPadding + 10, (this.barWidth - this.barPadding * 2) * this.player.oxygen / this.player.maxOxygen, this.barHeight - this.barPadding * 2);
      return this.drawText("oxygen", this.marginLeft, this.marginTop);
    };

    Chrome.prototype.drawMap = function(s, level) {
      var max_x, max_y, min_x, min_y, paddingLeft, paddingTop, planet, scale, x, y, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      this.s = s;
      min_x = max_x = min_y = max_y = -1;
      _ref = level.planets;
      _fn = function(planet) {
        var x, y;
        x = planet.x;
        y = planet.y * -1;
        min_x = min_x === -1 || x - planet.radius < min_x ? x - planet.radius : min_x;
        max_x = max_x === -1 || x + planet.radius > max_x ? x + planet.radius : max_x;
        min_y = min_y === -1 || y - planet.radius < min_y ? y - planet.radius : min_y;
        return max_y = max_y === -1 || y + planet.radius > max_y ? y + planet.radius : max_y;
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        planet = _ref[_i];
        _fn(planet);
      }
      scale = this.mapWidth / (max_x - min_x);
      if ((max_y - min_y) * scale > this.mapHeight) {
        scale = this.mapHeight / (max_y - min_y);
      }
      paddingLeft = (this.mapWidth - (max_x - min_x) * scale) / 2;
      paddingTop = (this.mapHeight - (max_y - min_y) * scale) / 2;
      /*
      		@s.stroke 255
      		@s.beginShape()
      		for planet in level.planets
      			do (planet) =>
      				x = paddingLeft + (planet.x - min_x) * scale
      				y = paddingTop + (-planet.y - min_y) * scale
      				@s.vertex 0, 0
      				@s.vertex x, y
      		@s.endShape()
      */

      _ref1 = level.planets;
      _fn1 = function(planet) {
        var size, x, y;
        x = _this.mapX + paddingLeft + (planet.x - min_x) * scale;
        y = _this.mapY + paddingTop + (-planet.y - min_y) * scale;
        size = planet.radius * 2 * scale;
        _this.s.noStroke();
        _this.s.fill(planet.color[0], planet.color[1], planet.color[2]);
        return _this.s.ellipse(x, y, size, size);
      };
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        planet = _ref1[_j];
        _fn1(planet);
      }
      x = this.mapX + paddingLeft + (level.startingPosition.x - min_x) * scale;
      y = this.mapY + paddingTop + (-level.startingPosition.y - min_y) * scale;
      return this.s.image(this.s["flying_left"], x - 20 / 2, y - 25);
    };

    Chrome.prototype.startLevel = function(s, level) {
      this.s = s;
      this.s.textAlign(this.s.CENTER);
      this.drawText(level.title, this.w / 2 + 100, this.h / 2 - 24, 24, true);
      this.drawText(level.description, this.w / 2 + 100, this.h / 2, 16, true);
      return this.s.textAlign(this.s.LEFT);
    };

    Chrome.prototype.dead = function(s) {
      var txt;
      this.s = s;
      this.s.textAlign(this.s.CENTER);
      txt = "DEAD! Try again?";
      this.drawText(txt, this.w / 2 + 100, this.h / 2, 24, true);
      return this.s.textAlign(this.s.LEFT);
    };

    Chrome.prototype.drawText = function(txt, x, y, size, centered) {
      var line, lines, _i, _len, _results;
      if (!txt) {
        txt = "";
      }
      if (!size) {
        size = 16;
      }
      if (centered === true) {
        ctx.textAlign = "center";
      } else {
        ctx.textAlign = "left";
      }
      ctx.font = size + 'px AudiowideRegular';
      lines = txt.split("\n");
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        ctx.fillStyle = 'black';
        ctx.fillText(line, x + 1.5, y + 1.5);
        ctx.fillStyle = 'white';
        ctx.fillText(line, x + .5, y + .5);
        _results.push(y += size * 1.4);
      }
      return _results;
      /*
      		@s.textFont(@s.loadedFont, size);
      		@s.fill 0
      		@s.text txt, x+1.5, y+1.5
      		@s.text txt, x+.5, y+1.5
      		@s.text txt, x+1.5, y+.5
      		@s.fill 255
      		@s.text txt, x+.5, y+.5
      */

    };

    return Chrome;

  })();

  w = 800;

  h = 480;

  rotation = 0;

  planets = [];

  currentLevel = 0;

  key_dir = -1;

  KEY_UP = 38;

  KEY_DOWN = 40;

  KEY_LEFT = 37;

  KEY_RIGHT = 39;

  KEY_SPACE = 32;

  MODE_START = "start";

  MODE_PLAY = "play";

  MODE_DEAD = "dead";

  MODE_FINISH = "finish";

  MODE_FINAL = "final";

  playMode = MODE_START;

  player = new Player();

  chrome = new Chrome(w, h);

  canvas = document.getElementById('canvas');

  ctx = canvas.getContext('2d');

  ctx.font = '14px "AudiowideRegular"';

  levels = [
    (new Level()).setTitle("Level 1: Hopscotch").setDescription("Get to the green planet for your oxygen runs out!\n\nUse LEFT/RIGHT arrow keys to walk around on planets.\n\nHold SPACE to jump, but watch the jump meter.\nJump too high, and you'll drift off into space!").setStageSize(w, h).setPlayer(player).setPlanets([new Planet(-50, -120, 70), new Planet(220, -40, 80), new Planet(-100, 280, 70), new Planet(250, 260, 80), new Planet(-50, 550, 80)]).setGoal(new Planet(300, 650, 90)).setPosition({
      x: -50,
      y: -40
    }).setOxygen(1200).setJump(40), (new Level()).setTitle("Level 2: Sunburn").setDescription("Watch out for hazards! The sun is HOT!").setStageSize(w, h).setPlayer(player).setPlanets([new Planet(-100, 450, 60), new Planet(100, 700, 70), new Planet(300, 1000, 100), new Planet(-50, -150, 100), new Sun(600, 600, 100)]).setGoal(new Planet(800, 850, 60)).setPosition({
      x: -50,
      y: -50
    }).setOxygen(1400).setJump(40), (new Level()).setTitle("Level 3: Total Eclipse of the Target").setDescription("This is not a straight shot. Use gravity to your advantage!").setStageSize(w, h).setPlayer(player).setPlanets([new Planet(200, 150, 60), new Planet(100, -700, 70), new Planet(-100, 400, 100), new Planet(-50, -50, 70), new Sun(100, -300, 100)]).setGoal(new Planet(-100, 950, 60)).setPosition({
      x: 100,
      y: -625
    }).setOxygen(1600).setJump(40)
  ];

  window.levels = levels;

  startGame = function() {
    levels[currentLevel].start();
    return playMode = MODE_PLAY;
  };

  startOver = function() {
    currentLevel = 0;
    return startGame();
  };

  death = function() {
    return playMode = MODE_DEAD;
  };

  finish = function() {
    if (currentLevel < levels.length - 1) {
      currentLevel += 1;
      return playMode = MODE_FINISH;
    } else {
      return playMode = MODE_FINAL;
    }
  };

  radio(player.DEAD).subscribe(death);

  radio(player.FINISHED).subscribe(finish);

  document.onkeyup = function(e) {
    if (key_dir === KEY_SPACE) {
      player.jump();
    }
    key_dir = -1;
    return player.walking = false;
  };

  document.onkeydown = function(e) {
    var cont;
    player = levels[currentLevel].player;
    rotation = levels[currentLevel].rotation;
    cont = false;
    switch (e.keyCode) {
      case KEY_UP:
        if (key_dir !== KEY_UP && 1 === 2) {
          key_dir = KEY_UP;
          player.accel(rotation - Math.PI, 10);
        }
        break;
      case KEY_DOWN:
        if (key_dir !== KEY_DOWN && 1 === 2) {
          key_dir = KEY_DOWN;
          player.accel(rotation, 10);
        }
        break;
      case KEY_LEFT:
        if (key_dir !== KEY_LEFT && player.onGround) {
          player.direction = player.DIR_LEFT;
          player.walking = true;
          player.accel(rotation - Math.PI / 2, 3, true);
        }
        break;
      case KEY_RIGHT:
        if (key_dir !== KEY_RIGHT && player.onGround) {
          player.direction = player.DIR_RIGHT;
          player.walking = true;
          player.accel(rotation + Math.PI / 2, 3, true);
        }
        break;
      case KEY_SPACE:
        if (key_dir !== KEY_SPACE && player.onGround) {
          key_dir = KEY_SPACE;
          player.startJumping();
        }
        switch (playMode) {
          case MODE_START:
            startGame();
            break;
          case MODE_DEAD:
            startGame();
            break;
          case MODE_FINISH:
            startGame();
            break;
          case MODE_FINAL:
            startOver();
        }
        break;
      default:
        cont = true;
    }
    if (!cont) {
      return e.preventDefault();
    }
  };

  canvas.onclick = function(e) {
    switch (playMode) {
      case MODE_START:
        return startGame();
      case MODE_DEAD:
        return startGame();
      case MODE_FINISH:
        return startGame();
      case MODE_FINAL:
        return startOver();
    }
  };

  runningOutColors = [
    {
      p: 0,
      r: 255,
      g: 0,
      b: 0
    }, {
      p: .3,
      r: 255,
      g: 255,
      b: 0
    }, {
      p: .7,
      r: 0,
      g: 200,
      b: 0
    }
  ];

  getColor = function(val, min, max, rules) {
    var c, c1, c2, i, lower, p, rule, upper, v, _i, _len;
    p = (val - min) / (max - min);
    if (p < 0) {
      p = 0;
    }
    if (p > 1) {
      p = 1;
    }
    lower = 0;
    for (i = _i = 0, _len = rules.length; _i < _len; i = ++_i) {
      rule = rules[i];
      if (rule.p <= p) {
        lower = i;
      }
    }
    if (lower < 0) {
      lower = 0;
    }
    upper = lower < rules.length - 1 ? lower + 1 : rules.length - 1;
    c1 = rules[lower];
    c2 = rules[upper];
    v = c2.p > c1.p ? (p - c1.p) / (c2.p - c1.p) : 0;
    return c = {
      r: c1.r + v * (c2.r - c1.r),
      g: c1.g + v * (c2.g - c1.g),
      b: c1.b + v * (c2.b - c1.b)
    };
  };

  setPixel = function(s, pixels, i) {
    if (Math.random() * 1000 < 2) {
      return pixels.setPixel(i, s.color(255, 255, 255));
    }
  };

  sketch(function() {
    var _this = this;
    this.setup = function() {
      var dir, dirs, i, img, imgs, p, pixel, _i, _j, _k, _len, _len1, _len2;
      _this.size(w, h);
      _this.background(0);
      _this.noFill();
      _this.frameRate(30);
      _this.loadedFont = _this.loadFont("fonts/Audiowide-Regular.ttf");
      imgs = [player.IMG_STANDING, player.IMG_WALKING, player.IMG_SQUATTING, player.IMG_FLYING, player.IMG_BURNT];
      dirs = [player.DIR_LEFT, player.DIR_RIGHT];
      for (_i = 0, _len = imgs.length; _i < _len; _i++) {
        img = imgs[_i];
        for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
          dir = dirs[_j];
          _this[img + "_" + dir] = _this.loadImage("images/spiff/" + img + "_" + dir + ".png");
        }
      }
      _this.stars = _this.createImage(1000, 1000, _this.ARGB);
      p = _this.stars.pixels.toArray();
      for (i = _k = 0, _len2 = p.length; _k < _len2; i = ++_k) {
        pixel = p[i];
        setPixel(_this, _this.stars.pixels, i);
      }
      _this.stars.updatePixels();
      chrome.s = _this;
      return _this;
    };
    return this.draw = function() {
      var txt;
      _this.background(0);
      switch (playMode) {
        case MODE_START:
          chrome.drawMap(_this, levels[currentLevel]);
          return chrome.startLevel(_this, levels[currentLevel]);
        case MODE_PLAY:
          levels[currentLevel].redraw(_this);
          return chrome.draw(_this, player);
        case MODE_DEAD:
          chrome.drawMap(_this, levels[currentLevel]);
          return chrome.dead(_this, levels[currentLevel]);
        case MODE_FINISH:
          chrome.drawMap(_this, levels[currentLevel]);
          chrome.startLevel(_this, levels[currentLevel]);
          return chrome.drawText(txt, w / 2 - _this.textWidth(txt) / 2, h / 2);
        case MODE_FINAL:
          txt = "FINISHED! Start over?";
          return chrome.drawText(txt, w / 2 - _this.textWidth(txt) / 2, h / 2);
      }
    };
  });

}).call(this);
